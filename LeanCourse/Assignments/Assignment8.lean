import LeanCourse.Common
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv
import Mathlib.Analysis.Calculus.Deriv.Prod
import Mathlib.Analysis.Calculus.Deriv.Pow

noncomputable section
open BigOperators Function Set Real Filter Classical Topology TopologicalSpace

/-! # Exercises to hand-in. -/

/- Here is a technical property using filters, characterizing when a 2-valued function converges to
a filter of the form `if q then F else G`. The next exercise is a more concrete application.
Useful lemmas here are
* `Filter.Eventually.filter_mono`
* `Filter.Eventually.mono` -/
lemma technical_filter_exercise {Œπ Œ± : Type*} {p : Œπ ‚Üí Prop} {q : Prop} {a b : Œ±}
    {L : Filter Œπ} {F G : Filter Œ±}
    (hbF : ‚àÄ·∂† x in F, x ‚â† b) (haG : ‚àÄ·∂† x in G, x ‚â† a) (haF : pure a ‚â§ F) (hbG : pure b ‚â§ G) :
    (‚àÄ·∂† i in L, p i ‚Üî q) ‚Üî
    Tendsto (fun i ‚Ü¶ if p i then a else b) L (if q then F else G) := by {
  have hab : a ‚â† b := by exact haF hbF
  rw [tendsto_iff_eventually]
  constructor
  ¬∑ intro hpq p' h
    apply hpq.mono
    intro _ peq
    rw [peq]
    by_cases hq : q
    ¬∑ simp [hq] at *
      exact haF h
    simp [hq] at *
    exact hbG h
  intro h
  sorry
  }

/- To be more concrete, we can use the previous lemma to prove the following.
if we denote the characteristic function of `A` by `1_A`, and `f : ‚Ñù ‚Üí ‚Ñù` is a function,
then  `f * 1_{s i}` tends to `f * 1_t` iff `x ‚àà s i` is eventually equivalent to
`x ‚àà t` for all `x`. (note that this does *not* necessarily mean that `s i = t` eventually).
`f * 1_t` is written `indicator t f` in Lean.
Useful lemmas for this exercise are `indicator_apply`, `apply_ite` and `tendsto_pi_nhds`. -/
lemma tendsto_indicator_iff {Œπ : Type*} {L : Filter Œπ} {s : Œπ ‚Üí Set ‚Ñù} {t : Set ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù}
    (ha : ‚àÄ x, f x ‚â† 0) :
    (‚àÄ x, ‚àÄ·∂† i in L, x ‚àà s i ‚Üî x ‚àà t) ‚Üî
    Tendsto (fun i ‚Ü¶ indicator (s i) f) L (ùìù (indicator t f)) := by {
    sorry
  }
